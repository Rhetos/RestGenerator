/*
    Copyright (C) 2014 Omega software d.o.o.

    This file is part of Rhetos.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as
    published by the Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using Rhetos.Compiler;
using Rhetos.Dsl;
using Rhetos.Extensibility;
using Rhetos.Utilities;
using System;
using System.ComponentModel.Composition;

namespace Rhetos.RestGenerator.Plugins
{
    /// <remarks>
    /// By default, WebServiceHost generated endpoints for generated services.
    /// We can customize endpoints and bindings by inserting custom C# code in RestServiceHost class, or by adding the service configuration in Web.config.
    /// Since the web service is a generic class, default WCF configuration reader will read a separate configuration for each Rhetos entity and other objects.
    /// For example, service and contract name would be `RestService.DataRestService`1[[assembly qualified name of the entity]]`.
    /// To allow service configuration in Web.config, the `ServiceContractConfiguration.Config` build option will generate service class attributes
    /// that read the configuration from web.config by specific name (service RestService, contract RestServiceContact).
    /// Unfortunately, after setting ServiceBehaviorAttribute.ConfigurationName, the WebServiceHost will no longer try to generate then endpoints automatically,
    /// so we cannot use this as a default option for RestGenerator.
    /// </remarks>
    enum ServiceContractConfiguration
    {
        /// <summary>
        /// Automatically generated by WebServiceHost (HTTP and HTTPS endpoints).
        /// </summary>
        Auto,
        /// <summary>
        /// Specified in Web.config file with service element. See readme.me for details.
        /// </summary>
        Config,
        /// <summary>
        /// Allow inserting custom ServiceContractAttribute in the generated service class.
        /// </summary>
        None
    };
    
    [Export(typeof(IRestGeneratorPlugin))]
    [ExportMetadata(MefProvider.Implements, typeof(RestServiceContractInfo))]
    public class RestServiceContractCodeGenerator : IRestGeneratorPlugin
    {
        public void GenerateCode(IConceptInfo conceptInfo, ICodeBuilder codeBuilder)
        {
            var info = (RestServiceContractInfo)conceptInfo;

            var serviceContractConfiguration = ConfigurationGetEnum("RestGenerator.ServiceContractConfiguration", ServiceContractConfiguration.Auto);

            string serviceContractAttributes;
            if (serviceContractConfiguration == ServiceContractConfiguration.Auto)
                serviceContractAttributes = "[ServiceContract]";
            else if (serviceContractConfiguration == ServiceContractConfiguration.Config)
                serviceContractAttributes = "[ServiceBehavior(ConfigurationName = \"RestService\")]\r\n    [ServiceContract(ConfigurationName = \"RestServiceContract\")]";
            else
                serviceContractAttributes = "";

            if (!string.IsNullOrEmpty(serviceContractAttributes))
                codeBuilder.InsertCode(serviceContractAttributes + "\r\n    ", info.ServiceClassAttributeTag);
        }

        private static T ConfigurationGetEnum<T>(string key, T defaultValue) where T : struct
        {
            var value = ConfigUtility.GetAppSetting(key);
            if (!string.IsNullOrEmpty(value))
            {
                if (Enum.TryParse(value, true, out T parsedValue))
                    return parsedValue;
                else
                    throw new FrameworkException(
                        $"Invalid '{key}' parameter in configuration file: '{value}' is not a valid value." +
                        $" Allowed values are: {string.Join(", ", Enum.GetNames(typeof(T)))}.");
            }
            else
                return defaultValue;
        }
    }
}
